---
title:  "[CSAPP] BOMB LAB 풀이"

categories:
  - csapp
tags:
  - [CS, csapp]

toc: true
toc_sticky: true
 
date: 2022-07-24
last_modified_at: 2022-07-24
---

## phase1
![bomblab_phase1_1](https://user-images.githubusercontent.com/106307725/180634855-eb991fef-1460-41ed-8a5f-3b84d71bdb39.png)  
  
어셈블리 코드를 관찰해보겠습니다. `strings_not_equal` 함수를 호출해서 나온 결과값은 `%rax`(의 하위 32bit인 `%eax`)에 들어있을 것입니다.  
  
`test`명령어로 `%eax & %eax` 연산을 수행했을 때 `0`이 나오면 `jump` 명령어로 인해 폭탄은 터지지 않고 정상적으로 해제되고, `0`이 아닌 다른 값이 나오면 폭탄이 터집니다.  
자기자신과 `&`연산을 한 결과가 `0`인 경우는 `%eax` 값이 `0`인 경우뿐입니다.  
  
함수명과 어셈블리코드에서 유추할 수 있듯 `strings_not_equal` 함수는 입력받은 문자열이 `%esi`에 들어있는 문자열과 일치하지 않으면 `1`을, 일치하면 `0`을 반환하는 함수입니다.  
  
그러면 우리가 해야할 일은 `0x402400`에 들어있는 문자열을 알아낸 후 똑같은 문자열을 입력해줘서 `jump`를 발생시키는 것입니다. 이를 위해 `x/s` 명령어를 사용합니다.  

![bomblab_phase1_2](https://user-images.githubusercontent.com/106307725/180635325-cd7df5ab-c826-468e-a113-8e6061734abd.png)  

즉, `0x402400`에 들어있는 문자열은
>Border relations with Canada have never been better.

그대로 입력해주면 phase1은 해결됩니다.

## phase2
`read_six_numbers` 함수를 먼저 찾아보겠습니다. `disas` 명령어를 사용한 결과는 다음과 같습니다.

![bomblab_phase2_2](https://user-images.githubusercontent.com/106307725/180639187-3c100359-d201-4643-836a-45a3a1e49710.png)  

`<+36>`에 있는 `$0x4025c3`에 뭐가 들어있는지 확인해봅니다.

![bomblab_phase2_3](https://user-images.githubusercontent.com/106307725/180639192-b5391623-da71-44b5-a4f9-625397294324.png)   
즉, 우리는 공백 하나를 사이에 두고 6개의 십진수 숫자를 입력해야함을 알 수 있습니다.  

이제 `phase_2`의 코드를 관찰해보겠습니다.  

![bomblab_phase2_1](https://user-images.githubusercontent.com/106307725/180639183-54d2dab0-4389-46ea-b1c0-227030d78b6b.png)  

먼저 `<+14>`를 보면 stack top의 값이 `0x1`이 아니면 폭탄이 터진다는 사실을 알 수 있습니다.  
그러므로 우리가 처음으로 입력해야 할 수는 `1`입니다.  
`%rbx`는 스택에서 우리가 숫자를 확인할 index라고 볼 수 있습니다.  
그리고 `<+27>`, `<+30>`, `<+32>`를 관찰해보면 `(스택의 현재 index에 있는 값) * 2 == 스택의 다음 index에 있는 값` 임을 알 수 있습니다.  
`<+62>`는 반복문에서 벗어날 조건문의 역할을 합니다.  
  
종합해보면, 처음 입력되어야 하는 수는 `1`이었고 그 뒤로는 계속 2배를 해주면 되는 것입니다.  

즉, 정답은  

> 1 2 4 8 16 32  

## phase3
![bomblab_phase3_1](https://user-images.githubusercontent.com/106307725/180645751-46665465-b308-4676-9e35-8eb771669fac.png)  

먼저, 입력 형식을 알기 위해 phase2에서 했던 것처럼 `x/s` 명령어를 사용합니다.  

![화면 캡처 2022-07-24 205459](https://user-images.githubusercontent.com/106307725/180645813-d637ddfa-e7f3-4c0d-93a6-8131d511aa78.png)  

공백 하나를 사이에 두고 십진수 두 개를 입력해야함을 알 수 있습니다.  
`<+39>` 을 보면, 첫번째로 입력한 인자는 0 이상, 7 이하입니다. (`ja` 명령어는 unsigned 형식으로 대소를 비교하기 때문입니다.)  
`<+50>` 을 보면 이 코드는 jump table이 있는 `switch-case` 문임을 알 수 있습니다. jump table의 내용을 보기 위해 다음과 같은 명령어를 입력합니다.  

![bomblab_phase3_2](https://user-images.githubusercontent.com/106307725/180645756-a571cab0-8df8-444b-b7a3-6b036b7c1af7.png)  
`x/[length][format] [Address Expression]` 형태의 명령어를 사용해 jump table의 요소들을 찾아낸 것입니다. (syntax 참고: <https://visualgdb.com/gdbreference/commands/x>)  
  
첫번째 인자는 0~7 사이 정수를 아무거나 정하면 되고, 그 첫 인자에 맞게 jump table을 참조하여 다음 인자를 고르면 됩니다.  
  
저의 경우  
>0 207  

로 하였습니다.

## phase4
![bomblab_phase4_1](https://user-images.githubusercontent.com/106307725/180710536-3c94ca14-ee3c-46da-abfa-598e3b8ab2fe.png)  

앞단계에서처럼, 입력 형식을 알아봅니다.  
  
![bomblab_phase4_2](https://user-images.githubusercontent.com/106307725/180710541-e06c9ad4-1705-45bb-aa9e-016e72f06e93.png)  
공백 하나를 사이에 두고 십진수 두 개를 입력해야함을 알 수 있습니다.  
  
`<+60>` 전까지는 사용자의 입력을 받고, 조건에 맞게 입력이 되었는지 확인하는 내용이니 건너뛰고 `func4` 함수를 보겠습니다.  
  
![bomblab_phase4_3](https://user-images.githubusercontent.com/106307725/180710545-92b77b71-e6a5-4f60-8dfa-7469a264b390.png)  
재귀적인 구조라는 것을 알 수 있습니다.
    
`<+22>`에서 조건이 충족되지 않으면 재귀적으로 함수를 호출합니다. 종료조건이 충족되면 `%eax`에 `0`을 넣어주고 반환합니다.  
그러면 그 마지막 함수를 호출한 함수는 이 `%eax`의 값에 2를 곱해주고 (`<+32>` 부분) 반환합니다.  
  
이런 식으로 계속해서 재귀적으로 호출되었던 함수들이 `%eax`에 2를 곱해주게 됩니다.  
가장 최초에 호출되었던 `func4`가 값을 반환하면 다시 원래의 `phase_4` 함수로 돌아갑니다.  
  
![bomblab_phase4_4](https://user-images.githubusercontent.com/106307725/180720645-567af785-7508-4d0a-9689-911505df2341.png)  
`phase_4` 함수의 끝부분입니다.  
  
`<+65>` 부분을 보면 `%eax`의 값은 `0`이어야 함을 알 수 있습니다. \\(x \times 2^k\\)의 값이 `0` 이라면 \\(x\\)는 `0`입니다. 고로 첫번째 인자는 `0`을 입력해야 합니다.  
  
`<+69>`와 `<+74>`를 보면 두 번째 인자도 `0`이라는 것을 알 수 있습니다.  
  
phase4의 정답은  
>0 0

## phase5
![bomblab_phase5_1](https://user-images.githubusercontent.com/106307725/180814383-2ac538d7-2edc-4415-a7c6-27daa0b261ad.png)  
  
![bomblab_phase5_2](https://user-images.githubusercontent.com/106307725/180814900-35f98e66-5e85-4302-9a8e-715b5b180a5c.png)  
먼저 비교대상이 되는 문자열을 확인해보면 `flyers`    
  
![bomblab_phase5_3](https://user-images.githubusercontent.com/106307725/180814906-1152746e-42fc-4582-b6e1-30a9879d6783.png)  
  
`phase_5` 함수에서 핵심적인 부분입니다.  
`string_length` 함수를 보면 알 수 있듯, `%rdi`는 우리가 입력한 문자열의 시작을 가리키는 포인터입니다.  
그러므로 `%rbx`는 문자열의 시작 주소이고 (`<+5>` 참고) `%rax`에는 `0`이 들어있습니다. (`<+112>` 참고)  
  
반복문을 해석해보겠습니다. `<+41>`에서 문자열을 `byte`단위로 읽어오고, 반복문이 작동하며 `%rax`의 값이 `1`씩 커지니까 한 `byte`씩 읽어들이는 것과 마찬가지입니다.  

이렇게 읽어들인 `byte`는 `%cl`(즉, `%rcx`의 `LSB`)과 `%rdx`에 저장됩니다.  
  
그리고 해당 `byte`를 `0000 1111`과 `&` 연산을 해서 `%rdx`에 저장했습니다.    
이제 `<+55>`에서 `Mem[0x4024b0 + %rdx]`에 접근해 알아낸 `byte`를 `%eax`에 넣습니다. `0000 1111`과의 `&` 연산을 `hash function`으로 갖는 `hash table`이라고 볼 수 있습니다.  
  
즉, `Mem[0x4024b0 + %rdx]` 값이 차례대로 f, l, y, e, r, s 여야 하는 것입니다.  
  
아스키 코드 값을 참고하면,  
f: 102  
l: 108  
y: 121  
e: 101  
r: 114  
s: 115  
입니다.    
`hash table`의 내용을 확인해보겠습니다. 우리는 소문자 알파벳에 대응되는 아스키 코드 값을 가진 메모리 주소를 알고 싶으므로 일단 `0x4024b0`부터 32개만 확인해보았습니다.  
  
![bomblab_phase5_4](https://user-images.githubusercontent.com/106307725/180817606-5a97d2e5-8b9f-4520-876e-28026d2171ac.png)  
  
알고보니 16개만 확인하면 됐던것 같습니다. 아무튼 이렇게 얻어낸 정보를 통해 어떻게 입력한 문자열을 `hashing`한 결과가 `flyers`가 되게 만들 것인지 알 수 있습니다.  
  
예를 들어, `f`, 즉 `102`를 얻기 위해서는 `Mem[0x4024b0 + 9]`에 접근해야 합니다. 따라서 첫번째 입력할 문자는 `____1001`(여기서 `_`는 `0`이든 `1`이든 상관없다는 뜻)의 아스키 코드를 가져야 합니다. 아스키 테이블을 참조하면 i, y, Y, ) 등이 있습니다. 이 중 아무거나 가져다 쓰면 됩니다. 어차피 `hash function`을 거치면 똑같은 메모리를 참조하게 됩니다.  
  
답은 여러가지 경우의 수가 있습니다.  
  
> ionefg

## phase6